\chapter{The Median Tree Problem}
\label{chap:mediantree}
Having surveyed the state of research on the \gls{pcstp} closely along with a
short summary of related problems. We now turn our eyes to the lattermost problem we have inspected:
\gls{mtp}.

As we noted in Chapter \ref{chap:related}, the problem involving the finding of \textit{median} trees
in graphs is not very well researched. To the best of our knowledge, no work has been put into solving
the problem in the general case to optimality. Being that this problem has some striking similarities
to the \gls{pcstp} -- that is, both problems involve finding the tree in a graph which minimises the sum
of the tree's edge costs and a penalty for every not-included vetex -- we suspect that refitting the
methods used to solve the \gls{pcstp} to the \gls{mtp} may result in good performance.

In this chapter, we will present a formal definition of the \acrlong{mtp} in Graphs. Then,
we will present a branch and cut algorithm and a solver for the \gls{mtp} which is inspired by the
work done on the \gls{pcstp}. Finally, we will present a dataset for the \gls{mtp} generated from a subset
of the DIMACs Steiner Tree challenge datasets for the \gls{pcstp}, and a set of experiments performed
on these.
 
\section{Problem Definition}

Let $G = (V, E, c, d)$ be an undirected graph. Denote $c : E \to \RR^+$ as an \textit{edge cost} function
and $d : V \times V  \to \RR^+$ be an \textit{assignment cost} function where we have
$$d_{ii} = 0 \mathnormal{.}$$
Then the \textit{\acrlong{mtp}}
is defined as finding a \textit{connected subgraph} $T = (V_T, E_T)$ of $G$
where $V_T \subseteq V$ and
$E_T \subseteq E$ which minimises the cost function,
$$c(T) = \sum_{ij \in E_T} c_{ij} + \sum_{i \in V} \min_{j \in V_T} d_{ij}\mathnormal{.}$$
We say that such a subgraph is a \textit{Median Tree} of $G$.

\begin{figure}[h]\centering
  \begin{subfigure}[b]{0.47\linewidth}\centering
    \begin{tikzpicture}[auto, node distance=1.5 cm]
      % Nodes
      \node[terminal] (a) {a};
      \node[terminal] (b) [right=of a] {b};
      \node[terminal] (c) [right=of b] {c};
      \node[terminal] (d) [above =of c] {d};
      \node[terminal] (e) [left=of d] {e};
      \node[terminal] (f) [left=of e] {f};
      \node[terminal] (g) [above right=0.75 and 1.3 of c] {g};
      % Edges
      \begin{scope}[every edge/.style={draw=black, thick}]
        \draw (a) edge node[below]{4} (b);
        \draw (b) edge node[near start]{5} (d);
        \draw (b) edge node[below]{8} (c);
        \draw (c) edge node{3} (d);
        \draw (c) edge node{2} (g);
        \draw (c) edge node[near start]{5} (e);
        \draw (d) edge node{6} (e);
        \draw (d) edge node{10} (g);
        \draw (e) edge node{1} (f);
      \end{scope}
    \end{tikzpicture}
    \caption{The graph $G$ with edge costs.}
    \label{fig:mtp:01:g}
  \end{subfigure}
  \begin{subfigure}[b]{0.47\linewidth}\centering
    \footnotesize
    \begin{tabular}{r||c|c|c|c|c|c|c}
 $d_{ij}$ & $a$ & $b$ & $c$ & $d$ & $e$ & $f$ & $g$ \\ \hline\hline
      $a$ &  0  &  5  &  8  &     &     &  6  &     \\ \hline
      $b$ &  2  &  0  &  2  &  2  &     &     &     \\ \hline
      $c$ &     &     &  0  & 10  &  4  &     &  1  \\ \hline
      $d$ &     &  3  &     &  0  &  6  &     &  2  \\ \hline
      $e$ &     &     &     &     &  0  &     &     \\ \hline
      $f$ &  2  &  8  &     &     &  5  &  0  &     \\ \hline
      $g$ &     &     &  5  &  5  &     &     &  0
    \end{tabular}
    \caption{The assignment cost function $d$.}
    \label{fig:mtp:01:d}
    \end{subfigure}
  \caption{Instance of the \gls{mtp} problem.}
  \label{fig:mtp:01}
\end{figure}

Figure \ref{fig:mtp:01} shows an example of the \gls{mtp} represented as a graph
(\ref{fig:mtp:01:g}) taken from our recurring example
and an assignment function (\ref{fig:mtp:01:d}) which has been chosen with
no specfic purpose.
Figure \ref{fig:mtp:01:opt}
shows the optimal solution
$$T = ( \{ c, e, f, g \}, \{(c, e), (c, g), (e, f)\})$$
to this problem with total cost
$$c(T) = (1 + 5 + 2) + (6 + 2 + 2) = 18\mathnormal{.}$$
\begin{figure}[h!]
  \centering
      \begin{tikzpicture}[auto, node distance=1.5 cm]
      % Nodes
      \node[terminal] (a) {a};
      \node[terminal] (b) [right=of a] {b};
      \node[terminal] (c) [right=of b] {c};
      \node[terminal] (d) [above =of c] {d};
      \node[terminal] (e) [left=of d] {e};
      \node[terminal] (f) [left=of e] {f};
      \node[terminal] (g) [above right=0.75 and 1.3 of c] {g};
      % Edges
      \begin{scope}[every edge/.style={draw=black, thick}]
        \draw (a) edge node[below]{4} (b);
        \draw (b) edge node[near start]{5} (d);
        \draw (b) edge node[below]{8} (c);
        \draw (c) edge node{3} (d);
        \draw (c) edge[selected] node{2} (g);
        \draw (c) edge[selected] node[near start]{5} (e);
        \draw (d) edge node{6} (e);
        \draw (d) edge node{10} (g);
        \draw (e) edge[selected] node{1} (f);
      \end{scope}
      \begin{scope}[every edge/.style={assignment}]
        \draw[->] (a) edge node{6} (f);
        \draw[->] (b) edge[bend right=60] node[below]{2} (c);
        \draw[->] (d) edge[bend left=60] node{2} (g);
      \end{scope}
    \end{tikzpicture}
    \caption{Optimal solution to the \gls{mtp} problem in Figure (\ref{fig:mtp:01}).
      The edges of the facility are coloured in red and assignments are denoted with translucent red arrows.}
    \label{fig:mtp:01:opt}
  \end{figure}

  Since there exists a relative balance between the cost of the edges in the graph and the assignment cost, $T$
  only spans part of the graph. This raises a point. As assignment costs tend to infinity, the \gls{mtp} begins to look
  like the Minimum Spanning Tree problem -- this is akin to the \gls{stp} with $N = V$ and the \gls{pcstp} with infinite prize
  on all vertices. However, when edge costs tend toward infinity, the facility will naturally become a single vertex
  and the \gls{mtp} starts looking like the $1$-Median problem (See Section \ref{sec:related:median}).
\todo[inline]{Maybe define terms Nonterminals and Supply points for vertices which
  respectively have either no assignment costs associated with them, are free to assign to any facility node,
  and are}

\paragraph{Reduction from the Prize-Collecting Steiner Tree Problem}
Instances of the \gls{pcstp} can straightforwardly be reduced to instances of the \gls{mtp}. This is in exact correspondence to how instances
of the Profitable Tour Problem can be reduced to instances of the Median Tour Problem (Section \ref{sec:related:median}).
Given an instance of the \gls{pcstp} on graph $G = (V, E, c, p)$, define the assignment cost function

$$d_{ij} =
 \begin{cases}
   0 & i = j \\
   p_i & i \neq j
 \end{cases}\mathnormal{.}
 $$
 then solving the \gls{mtp} on the graph $G' = (V, E, c, d)$ is equivalent to solving the \gls{pcstp} on $G$. Since every vertex assignment not
 to the vertex itself pays the \textit{prize} of that vertex, every vertex not in the facility will pay its prize as penalty. Hence,
 any solution $T = (V, E, c, p)$ to the \gls{pcstp} on $G$ will have the exact same cost as the solution $T' = (V, E, c, d)$ to the \gls{mtp} on $G'$.

\begin{figure}[h]\centering
  \begin{subfigure}[b]{0.47\linewidth}\centering
    \begin{tikzpicture}[auto, node distance=1.5 cm]
      % Nodes
      \node[terminal] (a) {a};
      \node[terminal] (b) [right=of a] {b};
      \node[terminal] (c) [right=of b] {c};
      \node[terminal] (d) [above =of c] {d};
      \node[terminal] (e) [left=of d] {e};
      \node[terminal] (f) [left=of e] {f};
      \node[terminal] (g) [above right=0.75 and 1.3 of c] {g};
      % Edges
      \begin{scope}[every edge/.style={draw=black, thick}]
        \draw (a) edge node[below]{4} (b);
        \draw (b) edge node[near start]{5} (d);
        \draw (b) edge node[below]{8} (c);
        \draw (c) edge node{3} (d);
        \draw (c) edge node{2} (g);
        \draw (c) edge node[near start]{5} (e);
        \draw (d) edge node{6} (e);
        \draw (d) edge node{10} (g);
        \draw (e) edge node{1} (f);
      \end{scope}
    \end{tikzpicture}
    \caption{The graph $G$ with edge costs.}
    \label{fig:mtp:pcstp:g}
  \end{subfigure}
  \begin{subfigure}[b]{0.47\linewidth}\centering
    \footnotesize
    \begin{tabular}{r||c|c|c|c|c|c|c}
 $d_{ij}$ & $a$ & $b$ & $c$ & $d$ & $e$ & $f$ & $g$ \\ \hline\hline
      $a$ &  0  &  12 &  12 &  12 &  12 &  12 &  12 \\ \hline
      $b$ &  0  &  0  &  0  &  0  &  0  &  0  &  0  \\ \hline
      $c$ &  0  &  0  &  0  & 0  &  0  &  0  &  0  \\ \hline
      $d$ &  10 &  10 &  10 &  0  &  10 &  10 &  10 \\ \hline
      $e$ &  0  &  0  &  0  &  0  &  0  &  0  &  0  \\ \hline
      $f$ &  0  &   0 &  0  &  0  &  0  &  0  &  0  \\ \hline
      $g$ &  3  &   3 &  3  &  3  &  3  &  3  &  0
    \end{tabular}
    \caption{The assignment cost function $d$.}
  \end{subfigure}

  \begin{subfigure}[b]{0.60\linewidth}\centering
    \begin{tikzpicture}[auto, node distance=1.5 cm]
      % Nodes
      \node[terminal] (a) {a};
      \node[terminal] (b) [right=of a] {b};
      \node[terminal] (c) [right=of b] {c};
      \node[terminal] (d) [above =of c] {d};
      \node[terminal] (e) [left=of d] {e};
      \node[terminal] (f) [left=of e] {f};
      \node[terminal] (g) [above right=0.75 and 1.3 of c] {g};
      % Edges
      \begin{scope}[every edge/.style={draw=black, thick}]
        \draw (a) edge[selected] node[below]{4} (b);
        \draw (b) edge[selected] node[near start]{5} (d);
        \draw (b) edge node[below]{8} (c);
        \draw (c) edge node{3} (d);
        \draw (c) edge node{2} (g);
        \draw (c) edge node[near start]{5} (e);
        \draw (d) edge node{6} (e);
        \draw (d) edge node{10} (g);
        \draw (e) edge node{1} (f);
      \end{scope}
      \begin{scope}[every edge/.style={assignment}]
        \draw[->] (c) edge[bend left=60] node{0} (b);
        \draw[->] (e) edge node[left]{0} (b);
        \draw[->] (f) edge node{0} (a);
        \draw[->] (g) edge[bend right=60] node[above]{3} (d);
      \end{scope}
    \end{tikzpicture}
    \caption{Optimal Solution to (\ref{fig:mtp:pcstp:g}).}
  \end{subfigure}

  \caption{Instance of the \gls{pcstp} (Figure \ref{fig:pcstp:01}) with optimal solution.}
  \label{fig:mtp:pcstp}
\end{figure}

Figure \ref{fig:mtp:pcstp} shows how this reduction works on the \gls{pcstp} instance in Figure \ref{fig:pcstp:01}
as well as the optimal solution
$$T = (\{a,b,d\}, \{(a,b), (b,d)\})$$
with cost
$$c(T) = (4 + 5) + (3) = 12$$
which is the same cost as the optimal solution to the original \gls{pcstp} problem (Figure \ref{fig:pcstp:01:opt}).

While it is obvious that the \gls{mtp} problem is NP-Hard -- something which has already been established in previous literature
 (See Section \ref{sec:related:median}) -- this reduction again implies the NP-Hardness of the problem.
\section{Applications}
\textit{* Any kind of supply situation: military / water (piping) / aid / maybe rail / postal}
\section{Integer Programming Formulation}

Given an instance of the \gls{mtp} as defined above,
Formulation (\ref{form:mtp:cut}) is an \gls{ilp} formulation of the \gls{mtp}.
It is loosely inspired by the one defined by \citet{lucena2004strong}
(Formulation \ref{form:lower:gsec}, Section \ref{sec:lower:gsec}) for the Prize-Collecting
Steiner Tree Problem.

The variables $\bd x$ and $\bd y$ are boolean
decision vectors which are interpreted as follows.
As with the \gls{pcstp} formulation, when $x_{ij} = 1$,
the edge between vertices $v_i$ and $v_j$ is part of the solution -- note that only
one of $x_{ij}$ and $x_{ji}$ are variables in model and we will use both indices interchangably
to refer to the same variable for the sake of readability.

Similarly, $\bd y$ describes the assignment relation of a solution. When
$y_{ij} = 1$, vertex $v_i$ is \textit{assigned} to vertex $v_j$ and the corresponding
assignment cost must be paid.
These relations are reflected in the objective function.
When $y_{kk} = 1$, we consider that vertex assigned to
itself, which implies that vertex $v_k$ is part of the facility.

 \begin{formulation}[h!]
   \begin{subequations}
     \begin{alignat}{3}
       &\underset{\bd x, \bd y}{\text{minimize}}
       & & \sum_{ij \in E} c_{ij} x_{ij} +  \sum_{i, j \in V} d_{ij}y_{ij}  & \\
       & \text{subject to}\quad
       & & \sum_{ij \in E} x_{ij} = \sum_{i \in V} y_{ii} - 1 &&  \label{form:mtp:tree}\\
       &&& x(E(S)) \leq \sum_{i \in S \setminus \{s\}} y_{ii}
       && \forall S \subseteq V, s \in S \label{form:mtp:gsec} \\
       &&& \sum_{j \in V} y_{kj} = 1 && \forall k \in V \label{form:mtp:assignment}\\
       &&& y_{ik} \leq  y_{kk}
       && \forall i, k \in V \label{form:mtp:facility}\\
       &&& y_{kk} \leq \sum_{i \in \gls{delta}(k)} x_{ik}
       && \forall k \in V \label{form:mtp:legal} \\
       &&& \bd x \in \BB^{|E|} && \\
       &&& \bd y \in \BB^{|V \times V|}
     \end{alignat}\label{form:mtp:cut}
   \end{subequations}
   \caption{TBD}
 \end{formulation}

 Since edges have nonnegative weights, we know that the shape of the facility must be a tree.
 Constraint (\ref{form:mtp:tree}) ensures that any facility has exactly one less edge than
 vertices, and constraints (\ref{form:mtp:gsec}) -- commonly known as \glspl{gsec}
 -- ensures that no subset of vertices in the facility can form
 a cycle. Together, these ensure that any feasible
 solution must be a single, connected subgraph of $G$
 which is shaped as a tree.

 The rest of the constraints are concerned with making sure that every vertex in $G$ is
 assigned to a vertex in the facility in any feasible solution. Constraint
 (\ref{form:mtp:assignment}) ensures that every vertex in $G$ is assigned to exactly one
 vertex, and constraint (\ref{form:mtp:facility}) ensures that a vertex can only be assigned
 to if it is part of the facility. This could alternatively be modelled as
 $$\sum_{i \in V} y_{ik} \leq  M y_{kk}  \qquad \forall i \in V$$
 for some $M \gg |V|$.

 Finally, the constraints (\ref{form:mtp:legal}) ensure that no vertex can feasibly be part
 of the facility unless an edge in its adjacency is selected -- that is, unless it is spanned
 by the solution tree.

 \paragraph{Valid Inequalities}
 Whenever a vertex is connected to the facility, it trivially must be assigned to itself. This
 follows directly from the fact that $d_{ii} = 0$ for all $i \in V$ and thus have $d_{ij} \geq d_{ii}$
 for all $j \in V$. The fact that this is implied by the probe (i.e. it is always correct to assign a
 vertex in the facility to itself) allows us to not formalise it in the problem. However, we can
 still add the constraints
 \begin{equation}\label{form:mtp:str}
 y_{ii} \geq x_{ji} \qquad \forall i \in V,  \forall j \in \delta(i)
\end{equation}
 to as valid constraints to formalise this relation.

 Similar to how \citeauthor{ljubic2005solving} constrain the degree of Nonterminals in Constraint
 (\ref{form:exact:strength}), the same idea holds for the \gls{mtp} but in a slightly different manner.
 Consider the set of vertices which cost nothing to assign and cannot be assigned to as \textit{Nonterminals},
 $$N = \left\{ i \in V \middle\vert \sum_{j \in v} d_{ij} = 0 \wedge  \forall j. d_{ji} = \infty\right\}\mathnormal{.}$$
 As nonterminals play no part in the assignment question, they cannot be a leaf node in an optimal solution as they could trivially
 be removed from the facility to produce a solution with no greater cost. Thus they
 must have degree of at least
 two should they be part of an optimal facility, and it is valid to add the constraint
 \begin{equation}\label{mtp:valid:deg}
   \sum_{j \in \delta(i)}x_{ij} \geq 2 x_{ik} \qquad \forall i \in N, \: \forall k \in \delta(i)
 \end{equation}
 to the model. The intuitive interpretation of (\ref{mtp:valid:deg}) is that if any edge adjacent to
 a nonterminal is selected, \textit{at least} two edges adjacent to the nonterminal must be selected.
\section{Solver}
As mentioned previously, to test out the applicability of some of the methods introduced in
the Chapter \ref{chap:solving}, we have implemented a solver for the \gls{mtp}.
This section both goes over algorithmic and technical implemention details of the solver

The solver makes use of the general purpose \gls{mip} solver
Gurobi\footnote{\url{https://www.gurobi.com/}} (version 8.0.1)
and its Python 3 interface. While this means that the callbacks written for the solver
will naturally have much slower performance than if, for example, we had chosen to make
use of the C or C++ interface, the Python interface was chosen for its higher level interface
and better ease-of-use -- giving better iteration times. Having no other computational results
to compare against, this trade-off was easy to make.

The Python library,
NetworkX\footnote{\url{https://networkx.github.io/}} \citep{hagberg2008exploring}
was used for the internal graph representation of the
problem instances in the solver as well as for implementation of common
graph algorithms. It is worth noting that NetworkX features algorithm implementations
in native Python instead of the more efficient Python C modules. This, again, has some
performance implications especially with regards to user callbacks (which we will
 touch on below).

The source code of the solver as well as the benchmark suite
can be found on GitHub\footnote{\url{https://github.com/wsprent/thesis-code}}.

\paragraph{Branch and Cut}
The choice of applying a branch and cut method in the solver, is fairly straight
forward to make as it is infeasible to load all of the exponential number of
\glspl{gsec} into the model initially. Thus, the solver
\textit{must} make use of
Gurobi's \textit{Lazy Constraints} to avoid producing infeasible solutions
and \textit{may} additionally make use of \textit{User Cuts} to potentially
give faster runtimes by producing tighter lower bounds.

Both of these are included in the solver through Gurobi's callback system.
\subparagraph{Lazy Constraints}
The job of the lazy constraint callback involves separating integer solutions
which violate any \glspl{gsec}. This boils down to finding cycles in the solution
graph.

Given an integer solution $(\bd{\hat{x}}, \bd{\hat{y}})$ produced by Gurobi, we
identify any violated \glspl{gsec} by first generating a NetworkX graph,
$$S = (\{i \in V \mid \hat y_{ii} = 1 \}, \{ (i, j) \in E \mid \hat x_{ij} = 1\})\mathnormal{.}$$
Then we again use NetworkX to find all simple cycles in $S$. Then for each vertex
subsets $C \subseteq V$ induced by a cycle
in $S$, we add all of the violated constraints
$$x(E(C)) \leq y_{ii} \setminus \{c\} \qquad \forall c \in C$$
to the model.
\subparagraph{User Cuts}
The callback responsible for
Separating infeasible LP solutions with regards to \glspl{gsec}
have been adapted for the solver from the max-flow/min-cut  method used by \citet{lucena2004strong}
 (see Section \ref{sec:solving:lower})
-- and later \citet{ljubic2005solving} and \citet{gamrath2017scip} -- for the \gls{pcstp}.

Adapting this separation procedure can be done directly. Having the decision variable
$\hat y_{ii} = b$ for some $b \in [0,1]$ in the LP relaxation of
the \gls{mtp} corresponds directly to $\hat y_i = b$ with respect to the \glspl{gsec}.
Once again, we use NetworkX to both represent the support graph and solve max flow problem(s).

As with the DHEA solver by \citet{ljubic2005solving}, we allow for controlling the maximum amount
of cuts performed at each node in the b\&b tree
with a \texttt{-{}-max-cuts} option. Additionally, this can be set
to \texttt{0} to disable the user cut routine altogether.

\paragraph{Primal Heuristics}
The solver an optional custom primal heuristic adapted from the primal hueristics detailed
for the \gls{pcstp} by \citet{ljubic2005solving}
(see Sections \ref{sec:solving:exact} and , \ref{sec:heuristics:lp}).

As with the cuts above, we exploit the fact that $y_i$ in the \gls{pcstp}
corresponds directly to $y_{ii}$ in the \gls{mtp}.

One thing we have not adapted, however, is the last step of solving the \gls{mtp}
on the final tree. This is left for further research.

The primal heuristic can be disabled in favour of Gurobi's inbuilt heuristic with
the switch \texttt{-{}-no-heuristics}.
\section{Computational Experience}

\subsection{Datasets}

\subsection{Results}

\begin{table}[h!]
  \centering
  \begin{tabular}[h!]{|c|c|c|c|c|c|}\hline
    \input{max-cut-table.tex}
  \end{tabular}
  \caption{Res}
  \label{tab:jmp:maxcut}
\end{table}

\begin{table}[h!]
  \centering
  \begin{tabular}[h!]{|c|c|c|c|c|}\hline
    \input{heuristics-table.tex}
  \end{tabular}
  \caption{Res}
  \label{tab:jmp:heuristics}
\end{table}

\begin{table}[h!]
  \centering
  \begin{tabular}[h!]{|c|c|c|c|c|}\hline
    \input{strengthen-table.tex}
  \end{tabular}
  \caption{Res}
  \label{tab:jmp:strengthen}
\end{table}

\section{Conclusion}

%%% Local Variables:
%%% TeX-master: "report"
%%% reftex-default-bibliography: ("lit.bib")
%%% End:
