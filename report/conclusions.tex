% \makeatletter
% \def\toclevel@chapter{-1}
% \makeatother
\bookmarksetup{startatroot}
\chapter{Conclusions}
This chapter serves as a summary of the work we have presented in this thesis.
Section~\ref{sec:con:fut} looks at some of the work which we think would be
interesting to explore, but have not either due to the scoping of our thesis or
time constraints.
Section~\ref{sec:con:con} then concludes this thesis with a look back at what we
have achieved (and not achieved) and presents what we think are our main results.
\section{Future Work}\label{sec:con:fut}
While we have done some work in this thesis, there is still plenty to do. We have
managed to a lot of questions than we have answered. Below are some of the open
questions which we think would be interesting to follow up on.

\subsection{Combinations of Preprocessing Routines}
In Section~\ref{sec:solving:pre} we discuss and describe preprocessing routines for
the \gls{pcstp}. This is done more in-depth by \citet{rehfeldt2016reduction}, who
additionally present a series of computational experiments which test single reduction
tests on a graph and also test a package of reduction tests.

They report that the ordering
in which preprocessing routines are applied \textit{does} matter and claim that running
the ``weakest'' routines first before moving on to the stronger, more costly routines.
However, they do not present results which show this.

We think it would be interesting to dive deeper into the dynamics between graph reduction
techniques. Uncovering which reduction tests enable eachother the most may lead to more
complex ordering of routines with potentially lower runtimes.

\subsection{Preprocessing for the MTP}
We did not spend much time dwelling on preprocessing for the \gls{mtp}. Our first goal was
to directly translate routines from the \gls{pcstp} and it was clear this was not possible
for its preprocessing routines.

However, while it seems like a hard problem due to the combinatorial size of the assignment
cost function, it may be that preprocessing routines could be a factor in solving the
\gls{mtp}.

We suspect that these routines will be more nich√© and more instance specific
than the ones for the \gls{pcstp}, relying
on specific graph formations, and it may well be that there simply aren't strong enough
invariant inherent in the \gls{mtp} to generate usefull preprocessing routines.

However, if it is possible to uncover some useful routines, we have seen with the \gls{pcstp}
just how big a different it can make.

\subsection{Directed Formulation of the MTP}

We have seen how \citet{ljubic2005solving} and \citet{gamrath2017scip}
make use of a transformation of
the \gls{pcstp} into an equivalent problem on a directed graph citing stronger
lower bounds from the LP relaxation.
  
It is not unlikely that this is the case for the \gls{mtp} as well. Thus, we propose
formulating a directed version of the \gls{mtp} and performing a comparative analysis
on the tightness of the lower bounds produced by its LP relaxation along with an
analysis on its effect on producing exact solutions for the \gls{mtp}.

\subsection{Refine the MTP Solver}

In Chapter~\ref{chap:mediantree}, we have proposed possible amendments to our solver to
solves some of its shortcomings.

The most poignant of these is probably the weakness of the Python 3 interface.
We stand by the ability of the Python interface to allow for faster iteration times,
which helped put together the solver in relatively short time.
However, at the same time, we have repeatedly
returned to the fact that Python as a callback interface is
inherently slower than a compiled system-programming language.
This ends up being a bit of a cop-out in our results section,
and it ends up clouding our ability
to distinguish between bad algorithms
and weak implementation.

To produce more satisfying experimental results, we believe it is a good idea to reimplement
the solver in a faster language, e.g. C++.

\paragraph{Primal Heuristic for the Median Tree Problem}
In Section~\ref{sec:mtp:solver} we detail a primal heuristic for the \gls{mtp}
which we translated directly from a primal heuristic for the \gls{pcstp}.
The final step of the algorithm did not translate directly, however, which potentially
results in a weaker heuristic.

Implementing a solver for the \gls{mtp} on tree based on results on literature
(see Section~\ref{sec:related:mtp}) may give improved results for our solver,
but the extra computational cost may also be a burden.

Alternatively, it could be interesting to take a look at implementing a search-based
heuristic for the \gls{mtp}, perhaps based on the work by \citet{canuto2001local}
for the \gls{pcstp}.

\subsection{Real World Datasets}
\citet{ljubic2006algorithmic}, along with their solver, produced two groups of real-world
instances modeled on the city of Cologne using GIS data and real world infrastructure.
These instances give a concrete example of application of the \gls{pcstp} with regards
to the deployment of fiber-optics networks, and contribute perhaps even more than
a new algorithm as they allow for the benchmarking of methods against realistic instances
for all subsequent algorithms.

We suggest that it would be worthwhile in and of itself to look into produce more of these
datasets, both for the \gls{mtp} and \gls{pcstp}.

\section{Conclusion}\label{sec:con:con}
In this thesis, we have surveyed the state of research on
an NP-hard combinatorial graph optimisation problem in
the \acrlong{pcstp}. We have given a detailed overview of state-of-the-art
methods used to solve this problem.
With this knowledge in hand, we have then implemented a solver for the related
\acrlong{mtp}, a generalisation of the \gls{pcstp}.

We have learned that the gls{pcstp}
is a well-research problem, and stands out as the most mature field of
research among related ``prize-collecting'' problems.
We have seen that research on the \gls{pcstp} is heavily based on corresponding
research on the \gls{stp}.

Furthermore, we have seen that some of the methods
---particularly within preprocessing---
are very sepecific to the \gls{pcstp} as they lean heavily on
invariants inherent in the problem itself. Thus, while preprocessing routines
are key results ---and widely used--- within the realm of the \gls{pcstp}
they are not easily transferable to other problems, if transferable at all.

Other areas with research on the \gls{pcstp} lend themselves much more to such
translations. We have shown this, by applying methods
with a varying degree of success for the
\gls{pcstp} in our solver for the \gls{mtp}.

While we have not seen perfect results for the methods we have translated
---in fact, more often than not, Gurobi's defaults are preferable---
we have no reason to believe that this is due to the methods not being
translatable. Particularly, we have seen that our primal heuristic implemented
in the relatively slow Python 3 interface gives ambivalent results in our experimental
section. This suggests that a stronger implementation may eclipse the default heuristic
altoghether.

% Main contributions
In conclusion, we have made four main contributions,
\begin{itemize}
\item A survey on the \gls{pcstp}. This survey serves as a comprehensive introduction
  and overview of research on the \gls{pcstp} and gives insight into the details of
  methods used to solve the \gls{pcstp}. Futhermore, for methods we do not cover
  in a detailed manner, it serves as an index for further reading.
\item An introduction to the \acrlong{mtp}, a NP-hard optimisation problem along with
  a problem defintion in the vein of the family of ``prize-collecting'' problems.
  Additionally, we have formulated the problem as an \gls{ilp} problem, using \glspl{gsec}.
\item A new small dataset for the \gls{mtp} which can be used to compare results, as well
  as tools to convert STP format data sets for the \gls{pcstp}. These tools can be used
  \textit{as-is} or modified to generate different kinds of instances.
\item A solver for the \gls{mtp}. This solver is able to solve the truncated version of
  our dataset to optimality, but not the full sized version within reasonable time.
\end{itemize}

Through this, we have explored and learned about the subject of
NP-hard graph optimisation problems from
the perspective of the \acrlong{pcstp}.



%%% Local Variables:
%%% TeX-master: "report"
%%% reftex-default-bibliography: ("lit.bib")
%%% End:
