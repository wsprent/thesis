#+STARTUP: latexpreview
* Solving the Prize-Collecting Steiner Tree Problem to Optimality :pcst:exact:algorithm:cplex:baseline:aborescence:
:PROPERTIES:
:bibtex: cite:ljubic2005solving
:END:
** Short Summary
Ljubic et. al. present an exact algorithm for solving PCSTP instances. This is done via running a Branch and Cut algorithm
 on a reduction of the orginal problem into a Steiner aborescence problem (directed graph).

 At each B&C node, the ILP formulation is relaxed by removing the integer constraints and removing the exponentially many 
"cut constraints". The relaxation is solved with CPLEX and cuts are made by readding violated "cut constraints" (found in
 poly time with max-flow). They don't describe how they find feasible solutions.
 
** ILP Formulation
Cut based.

Objective (Steiner Tree):
$$\text{minimize} \quad c(T) = \sum_{v \not\in V_T} p(v) + \sum_{e \in E_T} c(e)$$
Objective (Steiner Aborenscence):
$$minimize \quad c(SA) =  \sum_{i,j \in A_{SA}} c'_{ij} x_{ij} + \sum_{v \in V_{SA}} p(v)$$
Constraints:
- Exactly one arc points to each chosen vertice and zero to a not chosen vertice:
$$\sum_{ij \in A_{SA}}x_{ij} = y_i \qquad \forall i \in V_{SA} \setminus \{r\}$$
- Each subset of vertices which contains a selected vertice has in-degree larger than one (connected solution):
$$x(\delta^{-}(S)) \geq y_k \qquad \forall S \subset V_{SA};
 r \not\in S, k \in S $$
- Exactly one arc from the dummy root to the rest of the graph is selected:
$$\sum_{ri \in A_{SA}} x_{ri} = 1$$
- Integer Constraint:
$$x_{ij}, y_i \in \{0,1\} \qquad \forall (i,j) \in A_{SA}; \forall i \in V_{SA}$$
- Assymmetry constraint for unrooted PCSTP (always select root arc with lowest index -- to ensure bijection):
 $$x_{rj} \leq 1 - {y_j} \quad \forall i < j, i \in R$$

** Points
- Transform into Steiner Arborescence Problem (directed graph)
- Add root node
- Two arcs for each edge
- Algorithm in short:
  1. Solve LP-relaxtion.
  2. Cut away solutions by iteratively adding constraints based on max flow. 
     (Polynomial time; Goldberg)
- Tested on OR-Library and GIS-DATA

* A dual-ascent-based branch-and-bound framework for the prize-collecting Steiner tree and related problems :psct:aborescence:algorithm:exact:
:PROPERTIES:
:bibtex: cite:leitner2016dual
:END:
** Short Summary
Leitner et. al. present an exact algorithm for solving a variety of STP-related instances (including PCSTP). Problem instances are
 reduced to Steiner Aborescence instances. Then a branch and bound scheme is used. On each node, the LP-Dual is solved using Dual-Ascent.

A primal heuristics is used to find good incumbents {shortest path heuristic (SPH) (see Takahashi and Matsuyama 1980, Poggi de Arag Ìƒao and Werneck 2002)}.
 This is used alongside unioning exact solutions to subgraphs.

The Steiner Aborescence here contains fixed-terminals. Implementation of this algorithm is available [[https://github.com/mluipersbeck/dapcstp][here]].
** ILP Formulation

** Points
- Fully implemented exact solution with accessible source code (c++).
- Reduction to Steiner Aborescence
- Branch and Bound
  + Dual Ascent for LB.
  + Primal heuristics for incumbent.
  + Split on "fixed" terminals (analogous to actual STP terminals).
- DIMACS Challenge
** Further Work Needed

*** TODO Fully understand the Dual
The dual formulation is a bit exotic, but probably important to understand.
- Look in Goemans/Williamson for intuition for "node potential"
- Apparently a generalisation of a dual scheme in Wong.
- Implementation based on (T. Pajor, E. Uchoa, and R. F. Werneck. A robust and scalable algorithm for the Steiner problem in graphs. 2014. 11th DIMACS challenge workshop.)

* The Prize Collecting Steiner Tree Problem: Theory and Practice :psct:approximation:algorithm:
:PROPERTIES:
:bibtex: cite:Johnson:2000:PCS:338219.338637
:END:
** Short Summary
Johnson et. al. present modifications to the Goemans Williamson algorithm (2-approximation). Their main contribution
 is the replacement of the pruning phase of the algorithm with "strong pruning". They experimentally claim to see a
 5% optimality gap from their algorithm.

** Further Work
- Think about whether or not approximation algorithms are intresting.
- Take a look at the original GW algorithm.
